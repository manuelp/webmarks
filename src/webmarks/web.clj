(ns webmarks.web
  (:use compojure.core)
  (:require (compojure [handler :as handler]
                       [route :as route])
            [cemerick.friend :as friend]
            (cemerick.friend [workflows :as workflows]
                             [credentials :as creds])
            (webmarks [views :as view]
                      [mutable :as mutable])
            [ring.adapter.jetty :as jetty]
            (ring.util [response :as response]
                       [codec :as rc]))
  (:gen-class))

(def users {"admin" {:username "admin"
                    :password (creds/hash-bcrypt "password")
                    :roles #{::admin}}
            "manuel" {:username "manuel"
                      :password (creds/hash-bcrypt (or (System/getenv "PASSWORD")
                                                       "password"))
                      :roles #{::user}}})

(derive ::admin ::user)

(def webmarks-filename (atom ""))

(defroutes app*
  (route/resources "/")
  (GET "/" [] (view/layout "WebMarks!"))
  (GET "/authorized" request
       (friend/authorize #{::user} "This page can only be seen by authenticated users."))
  (GET "/admin" request
       (friend/authorize #{::admin} "This page can only be seen by administrators."))
  (GET "/login" [] (view/login-page "WebMarks - Login"))

  (GET "/list" [] (view/webmarks-page "WebMarks - List" @mutable/webmarks))
  (GET "/tags" [] (view/tags-page "WebMarks - Tags" (sort (mutable/tags-list))))
  (GET "/search/by-tag/:tag" [tag]
       (view/webmarks-page (str "WebMarks - Tag: " tag)
                           (mutable/filter-by-tags [tag])))
  (GET "/add" [] (view/add-webmark "WebMarks - Add New"))
  (POST "/add" [url tags] (do
                            (mutable/add-new-webmark url tags)
                            (mutable/save-webmarks! @webmarks-filename)
                            (response/redirect-after-post "/")))
  (GET "/edit/:encoded-url"
       [encoded-url]
       (let [url (rc/url-decode encoded-url)]
         (view/edit-webmark "WebMarks - Edit" url (get @mutable/webmarks url))))
  (POST "/edit/:encoded-url" [encoded-url new-tag & checked]
        (let [url (rc/url-decode encoded-url)
              tags-to-remove (vals checked)]
          (doall (map (partial mutable/remove-tag url) tags-to-remove))
          (if new-tag (mutable/add-tag url new-tag))
          (response/redirect-after-post (str "/edit/" (rc/url-encode url)))))
  (GET "/delete/:encoded-url"
       [encoded-url]
       (let [url (rc/url-decode encoded-url)]
         (mutable/remove-webmark url)
         (response/redirect "/")))
  
  (friend/logout (ANY "/logout" request (response/redirect "/")))
  (route/not-found "Not Found"))

;; The Ring handler generated by Compojure is enriched by the
;; Compojure's `site` middleware (a composition of Ring middlewares,
;; see
;; [documentation](http://weavejester.github.com/compojure/compojure.handler.html#var-api))
;; and bound to a var.
(def app
  (handler/site
   (friend/authenticate app*
   			{:credential-fn (partial creds/bcrypt-credential-fn users)
                         :workflows [(workflows/interactive-form)]})))

;; This way, we can start the embedded Jetty server and dynamically
;; change our handler rebinding `app` at will without having to
;; restart the server.
(defn -main [& args]
  (let [port (or (and (first args)
                      (Integer/parseInt (first args)))
                 (and (System/getenv "PORT")
                      (Integer/parseInt (System/getenv "PORT")))
                 8080)
        edn-filename (or (second args)
                         (System/getenv "WEBMARKS_FILE")
                         "webmarks.edn")]
    (do
      (mutable/load-webmarks! edn-filename)
      (reset! webmarks-filename edn-filename)
      (jetty/run-jetty #'app {:port port :join? false}))))